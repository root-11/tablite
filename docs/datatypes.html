<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tablite.datatypes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tablite.datatypes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import date, datetime, time


class DataTypes(object):
    # supported datatypes.
    int = int
    str = str
    float = float
    bool = bool
    date = date
    datetime = datetime
    time = time

    numeric_types = {int, float, date, time, datetime}
    digits = &#39;1234567890&#39;
    decimals = set(&#39;1234567890-+eE.&#39;)
    integers = set(&#39;1234567890-+&#39;)
    nones = {&#39;null&#39;, &#39;Null&#39;, &#39;NULL&#39;, &#39;#N/A&#39;, &#39;#n/a&#39;, &#34;&#34;, &#39;None&#39;, None}
    none_type = type(None)

    date_formats = {  # Note: Only recognised ISO8601 formats are accepted.
        &#34;NNNN-NN-NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-N-NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-NN-N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-N-N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NN-NN-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;N-NN-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;NN-N-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;N-N-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;NNNN.NN.NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.N.NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.NN.N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.N.N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NN.NN.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;N.NN.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;NN.N.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;N.N.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;NNNN/NN/NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/N/NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/NN/N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/N/N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NN/NN/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;N/NN/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;NN/N/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;N/N/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;NNNN NN NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN N NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN NN N&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN N N&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NN NN NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;N N NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;NN N NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;N NN NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;NNNNNNNN&#34;: lambda x: date(*(int(x[:4]), int(x[4:6]), int(x[6:]))),
    }

    datetime_formats = {
        # Note: Only recognised ISO8601 formats are accepted.

        # year first
        &#39;NNNN-NN-NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x),  # -T
        &#39;NNNN-NN-NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x),

        &#39;NNNN-NN-NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, T=&#34; &#34;),  # - space
        &#39;NNNN-NN-NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, T=&#34; &#34;),

        &#39;NNNN/NN/NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;),  # / T
        &#39;NNNN/NN/NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;),

        &#39;NNNN/NN/NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#34; &#34;),  # / space
        &#39;NNNN/NN/NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#34; &#34;),

        &#39;NNNN NN NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;),  # space T
        &#39;NNNN NN NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;),

        &#39;NNNN NN NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;, T=&#34; &#34;),  # space
        &#39;NNNN NN NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;, T=&#34; &#34;),

        &#39;NNNN.NN.NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;),  # dot T
        &#39;NNNN.NN.NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;),

        &#39;NNNN.NN.NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, T=&#34; &#34;),  # dot
        &#39;NNNN.NN.NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, T=&#34; &#34;),


        # day first
        &#39;NN-NN-NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),  # - T
        &#39;NN-NN-NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN-NN-NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),  # - space
        &#39;NN-NN-NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN/NN/NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # / T
        &#39;NN/NN/NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN/NN/NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#39; &#39;, day_first=True),  # / space
        &#39;NN/NN/NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN NN NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # space T
        &#39;NN NN NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN NN NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # space
        &#39;NN NN NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN.NN.NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),  # space T
        &#39;NN.NN.NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),

        &#39;NN.NN.NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),  # space
        &#39;NN.NN.NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),

        # compact formats - type 1
        &#39;NNNNNNNNTNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        &#39;NNNNNNNNTNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        &#39;NNNNNNNNTNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        # compact formats - type 2
        &#39;NNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        &#39;NNNNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        &#39;NNNNNNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        # compact formats - type 3
        &#39;NNNNNNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=3),
    }

    @staticmethod
    def pattern_to_datetime(iso_string, ymd=None, T=None, compact=0, day_first=False):
        assert isinstance(iso_string, str)
        if compact:
            s = iso_string
            if compact == 1:  # has T
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (11, 13, &#34;:&#34;), (13, len(s), &#34;&#34;)]
            elif compact == 2:  # has no T.
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (8, 10, &#34;:&#34;), (10, 12, &#34;:&#34;), (12, len(s), &#34;&#34;)]
            elif compact == 3:  # has T and :
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (12, 14, &#34;:&#34;), (15, len(s), &#34;&#34;)]
            else:
                raise TypeError
            iso_string = &#34;&#34;.join([s[a:b] + c for a, b, c in slices if b &lt;= len(s)])
            iso_string = iso_string.rstrip(&#34;:&#34;)

        if day_first:
            s = iso_string
            iso_string = &#34;&#34;.join((s[6:10], &#34;-&#34;, s[3:5], &#34;-&#34;, s[0:2], s[10:]))

        if &#34;,&#34; in iso_string:
            iso_string = iso_string.replace(&#34;,&#34;, &#34;.&#34;)

        dot = iso_string[::-1].find(&#39;.&#39;)
        if 0 &lt; dot &lt; 10:
            ix = len(iso_string) - dot
            microsecond = int(float(f&#34;0{iso_string[ix - 1:]}&#34;) * 10 ** 6)
            iso_string = iso_string[:len(iso_string) - dot] + str(microsecond).rjust(6, &#34;0&#34;)
        if ymd:
            iso_string = iso_string.replace(ymd, &#39;-&#39;, 2)
        if T:
            iso_string = iso_string.replace(T, &#34;T&#34;)
        return datetime.fromisoformat(iso_string)

    @staticmethod
    def to_json(v):
        if v is None:
            return v
        elif v is False:  # using isinstance(v, bool): won&#39;t work as False also is int of zero.
            return str(v)
        elif v is True:
            return str(v)
        elif isinstance(v, int):
            return v
        elif isinstance(v, str):
            return v
        elif isinstance(v, float):
            return v
        elif isinstance(v, datetime):
            return v.isoformat()
        elif isinstance(v, time):
            return v.isoformat()
        elif isinstance(v, date):
            return v.isoformat()
        else:
            raise TypeError(f&#34;The datatype {type(v)} is not supported.&#34;)

    @staticmethod
    def from_json(v, dtype):
        if v in DataTypes.nones:
            if dtype is str and v == &#34;&#34;:
                return &#34;&#34;
            else:
                return None
        if dtype is int:
            return int(v)
        elif dtype is str:
            return str(v)
        elif dtype is float:
            return float(v)
        elif dtype is bool:
            if v == &#39;False&#39;:
                return False
            elif v == &#39;True&#39;:
                return True
            else:
                raise ValueError(v)
        elif dtype is date:
            return date.fromisoformat(v)
        elif dtype is datetime:
            return datetime.fromisoformat(v)
        elif dtype is time:
            return time.fromisoformat(v)
        else:
            raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)

    @staticmethod
    def infer(v, dtype):
        if v in DataTypes.nones:
            return None
        if dtype is int:
            return DataTypes._infer_int(v)
        elif dtype is str:
            return DataTypes._infer_str(v)
        elif dtype is float:
            return DataTypes._infer_float(v)
        elif dtype is bool:
            return DataTypes._infer_bool(v)
        elif dtype is date:
            return DataTypes._infer_date(v)
        elif dtype is datetime:
            return DataTypes._infer_datetime(v)
        elif dtype is time:
            return DataTypes._infer_time(v)
        else:
            raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)

    @staticmethod
    def _infer_bool(value):
        if isinstance(value, bool):
            return value
        elif isinstance(value, int):
            raise ValueError(&#34;it&#39;s an integer.&#34;)
        elif isinstance(value, float):
            raise ValueError(&#34;it&#39;s a float.&#34;)
        elif isinstance(value, str):
            if value.lower() == &#34;true&#34;:
                return True
            elif value.lower() == &#34;false&#34;:
                return False
            else:
                raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_int(value):
        if isinstance(value, bool):
            raise ValueError(&#34;it&#39;s a boolean&#34;)
        if isinstance(value, int):
            return value
        elif isinstance(value, float):
            if int(value) == value:
                return int(value)
            raise ValueError(&#34;it&#39;s a float&#34;)
        elif isinstance(value, str):
            value = value.replace(&#39;&#34;&#39;, &#39;&#39;)  # &#34;1,234&#34; --&gt; 1,234
            value = value.replace(&#34; &#34;, &#34;&#34;)  # 1 234 --&gt; 1234
            value = value.replace(&#39;,&#39;, &#39;&#39;)  # 1,234 --&gt; 1234
            value_set = set(value)
            if value_set - DataTypes.integers:  # set comparison.
                raise ValueError
            try:
                return int(value)
            except Exception:
                raise ValueError(f&#34;{value} is not an integer&#34;)
        else:
            raise ValueError

    @staticmethod
    def _infer_float(value):
        if isinstance(value, int):
            raise ValueError(&#34;it&#39;s an integer&#34;)
        if isinstance(value, float):
            return value
        elif isinstance(value, str):
            value = value.replace(&#39;&#34;&#39;, &#39;&#39;)
            dot_index, comma_index = value.find(&#39;.&#39;), value.find(&#39;,&#39;)
            if dot_index == comma_index == -1:
                pass  # there are no dots or commas.
            elif 0 &lt; dot_index &lt; comma_index:  # 1.234,567
                value = value.replace(&#39;.&#39;, &#39;&#39;)  # --&gt; 1234,567
                value = value.replace(&#39;,&#39;, &#39;.&#39;)  # --&gt; 1234.567
            elif dot_index &gt; comma_index &gt; 0:  # 1,234.678
                value = value.replace(&#39;,&#39;, &#39;&#39;)

            elif comma_index and dot_index == -1:
                value = value.replace(&#39;,&#39;, &#39;.&#39;)
            else:
                pass

            value_set = set(value)

            if not value_set.issubset(DataTypes.decimals):
                raise TypeError

            # if it&#39;s a string, do also
            # check that reverse conversion is valid,
            # otherwise we have loss of precision. F.ex.:
            # int(0.532) --&gt; 0
            try:
                float_value = float(value)
            except Exception:
                raise ValueError(f&#34;{value} is not a float.&#34;)
            if value_set.intersection(&#39;Ee&#39;):  # it&#39;s scientific notation.
                v = value.lower()
                if v.count(&#39;e&#39;) != 1:
                    raise ValueError(&#34;only 1 e in scientific notation&#34;)

                e = v.find(&#39;e&#39;)
                v_float_part = float(v[:e])
                v_exponent = int(v[e + 1:])
                return float(f&#34;{v_float_part}e{v_exponent}&#34;)

            elif &#34;.&#34; in str(float_value) and not &#34;.&#34; in value_set:
                # when traversing through Datatype.types,
                # integer is presumed to have failed for the column,
                # so we ignore this and turn it into a float...
                reconstructed_input = str(int(float_value))

            elif &#34;.&#34; in value:
                precision = len(value) - value.index(&#34;.&#34;) - 1
                formatter = &#39;{0:.&#39; + str(precision) + &#39;f}&#39;
                reconstructed_input = formatter.format(float_value)

            else:
                reconstructed_input = str(float_value)

            if value.lower() != reconstructed_input:
                raise ValueError

            return float_value
        else:
            raise ValueError

    @staticmethod
    def _infer_date(value):
        if isinstance(value, date):
            return value
        elif isinstance(value, str):
            try:
                return date.fromisoformat(value)
            except ValueError:
                pattern = &#34;&#34;.join([&#34;N&#34; if n in DataTypes.digits else n for n in value])
                f = DataTypes.date_formats.get(pattern, None)
                if f:
                    return f(value)
                else:
                    raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_datetime(value):
        if isinstance(value, datetime):
            return value
        elif isinstance(value, str):
            try:
                return datetime.fromisoformat(value)
            except ValueError:
                if &#39;.&#39; in value:
                    dot = value.find(&#39;.&#39;, 11)  # 11 = len(&#34;1999.12.12&#34;)
                elif &#39;,&#39; in value:
                    dot = value.find(&#39;,&#39;, 11)
                else:
                    dot = len(value)

                pattern = &#34;&#34;.join([&#34;N&#34; if n in DataTypes.digits else n for n in value[:dot]])
                f = DataTypes.datetime_formats.get(pattern, None)
                if f:
                    return f(value)
                else:
                    raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_time(value):
        if isinstance(value, time):
            return value
        elif isinstance(value, str) and &#34;:&#34; in value:
            # beware time.fromisoformat reads &#34;20&#34; as &#34;20:00:00&#34;, despite that it is more likely to be an integer.
            return time.fromisoformat(value)
        else:
            raise ValueError

    @staticmethod
    def _infer_str(value):
        if isinstance(value, str):
            return value
        else:
            return str(value)

    # Order is very important!
    types = [datetime, date, time, int, bool, float, str]

    @staticmethod
    def infer_range_from_slice(slice_item, length):
        assert isinstance(slice_item, slice)
        assert isinstance(length, int)
        item = slice_item

        if all((item.start is None,
               item.stop is None,
               item.step is None)):
            return 0, length, 1

        if item.step is None or item.step &gt; 0:  # forward traverse
            step = 1 if item.step is None else item.step
            if item.start is None:
                start = 0
            elif item.start &lt; 0:
                start = length + item.start
            else:
                start = item.start

            if item.stop is None or item.stop &gt; length:
                stop = length
            elif item.stop &lt; 0:
                stop = length + item.stop
            else:
                stop = item.stop

        elif item.step == 0:
            raise ValueError(&#34;slice step cannot be zero&#34;)

        else:  # item.step &lt; 0: backward traverse
            step = item.step
            if item.start is None:  # a[::-1]
                start = length
            elif item.start &lt; 0:
                start = item.start + length
            else:
                start = item.start

            if item.stop is None:
                stop = 0
            elif item.stop &lt; 0:
                stop = item.stop + length
            else:
                stop = item.stop

        return start, stop, step</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tablite.datatypes.DataTypes"><code class="flex name class">
<span>class <span class="ident">DataTypes</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypes(object):
    # supported datatypes.
    int = int
    str = str
    float = float
    bool = bool
    date = date
    datetime = datetime
    time = time

    numeric_types = {int, float, date, time, datetime}
    digits = &#39;1234567890&#39;
    decimals = set(&#39;1234567890-+eE.&#39;)
    integers = set(&#39;1234567890-+&#39;)
    nones = {&#39;null&#39;, &#39;Null&#39;, &#39;NULL&#39;, &#39;#N/A&#39;, &#39;#n/a&#39;, &#34;&#34;, &#39;None&#39;, None}
    none_type = type(None)

    date_formats = {  # Note: Only recognised ISO8601 formats are accepted.
        &#34;NNNN-NN-NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-N-NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-NN-N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NNNN-N-N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;-&#34;))),
        &#34;NN-NN-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;N-NN-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;NN-N-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;N-N-NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;-&#34;)][::-1]),
        &#34;NNNN.NN.NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.N.NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.NN.N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NNNN.N.N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;.&#34;))),
        &#34;NN.NN.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;N.NN.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;NN.N.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;N.N.NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;.&#34;)][::-1]),
        &#34;NNNN/NN/NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/N/NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/NN/N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NNNN/N/N&#34;: lambda x: date(*(int(i) for i in x.split(&#34;/&#34;))),
        &#34;NN/NN/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;N/NN/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;NN/N/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;N/N/NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34;/&#34;)][::-1]),
        &#34;NNNN NN NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN N NN&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN NN N&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NNNN N N&#34;: lambda x: date(*(int(i) for i in x.split(&#34; &#34;))),
        &#34;NN NN NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;N N NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;NN N NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;N NN NNNN&#34;: lambda x: date(*[int(i) for i in x.split(&#34; &#34;)][::-1]),
        &#34;NNNNNNNN&#34;: lambda x: date(*(int(x[:4]), int(x[4:6]), int(x[6:]))),
    }

    datetime_formats = {
        # Note: Only recognised ISO8601 formats are accepted.

        # year first
        &#39;NNNN-NN-NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x),  # -T
        &#39;NNNN-NN-NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x),

        &#39;NNNN-NN-NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, T=&#34; &#34;),  # - space
        &#39;NNNN-NN-NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, T=&#34; &#34;),

        &#39;NNNN/NN/NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;),  # / T
        &#39;NNNN/NN/NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;),

        &#39;NNNN/NN/NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#34; &#34;),  # / space
        &#39;NNNN/NN/NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#34; &#34;),

        &#39;NNNN NN NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;),  # space T
        &#39;NNNN NN NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;),

        &#39;NNNN NN NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;, T=&#34; &#34;),  # space
        &#39;NNNN NN NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39; &#39;, T=&#34; &#34;),

        &#39;NNNN.NN.NNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;),  # dot T
        &#39;NNNN.NN.NNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;),

        &#39;NNNN.NN.NN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, T=&#34; &#34;),  # dot
        &#39;NNNN.NN.NN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, T=&#34; &#34;),


        # day first
        &#39;NN-NN-NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),  # - T
        &#39;NN-NN-NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN-NN-NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),  # - space
        &#39;NN-NN-NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;-&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN/NN/NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # / T
        &#39;NN/NN/NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN/NN/NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#39; &#39;, day_first=True),  # / space
        &#39;NN/NN/NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, T=&#39; &#39;, day_first=True),

        &#39;NN NN NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # space T
        &#39;NN NN NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN NN NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),  # space
        &#39;NN NN NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;/&#39;, day_first=True),

        &#39;NN.NN.NNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),  # space T
        &#39;NN.NN.NNNNTNN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),

        &#39;NN.NN.NNNN NN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),  # space
        &#39;NN.NN.NNNN NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, ymd=&#39;.&#39;, day_first=True),

        # compact formats - type 1
        &#39;NNNNNNNNTNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        &#39;NNNNNNNNTNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        &#39;NNNNNNNNTNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=1),
        # compact formats - type 2
        &#39;NNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        &#39;NNNNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        &#39;NNNNNNNNNNNNNN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=2),
        # compact formats - type 3
        &#39;NNNNNNNNTNN:NN:NN&#39;: lambda x: DataTypes.pattern_to_datetime(x, compact=3),
    }

    @staticmethod
    def pattern_to_datetime(iso_string, ymd=None, T=None, compact=0, day_first=False):
        assert isinstance(iso_string, str)
        if compact:
            s = iso_string
            if compact == 1:  # has T
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (11, 13, &#34;:&#34;), (13, len(s), &#34;&#34;)]
            elif compact == 2:  # has no T.
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (8, 10, &#34;:&#34;), (10, 12, &#34;:&#34;), (12, len(s), &#34;&#34;)]
            elif compact == 3:  # has T and :
                slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (12, 14, &#34;:&#34;), (15, len(s), &#34;&#34;)]
            else:
                raise TypeError
            iso_string = &#34;&#34;.join([s[a:b] + c for a, b, c in slices if b &lt;= len(s)])
            iso_string = iso_string.rstrip(&#34;:&#34;)

        if day_first:
            s = iso_string
            iso_string = &#34;&#34;.join((s[6:10], &#34;-&#34;, s[3:5], &#34;-&#34;, s[0:2], s[10:]))

        if &#34;,&#34; in iso_string:
            iso_string = iso_string.replace(&#34;,&#34;, &#34;.&#34;)

        dot = iso_string[::-1].find(&#39;.&#39;)
        if 0 &lt; dot &lt; 10:
            ix = len(iso_string) - dot
            microsecond = int(float(f&#34;0{iso_string[ix - 1:]}&#34;) * 10 ** 6)
            iso_string = iso_string[:len(iso_string) - dot] + str(microsecond).rjust(6, &#34;0&#34;)
        if ymd:
            iso_string = iso_string.replace(ymd, &#39;-&#39;, 2)
        if T:
            iso_string = iso_string.replace(T, &#34;T&#34;)
        return datetime.fromisoformat(iso_string)

    @staticmethod
    def to_json(v):
        if v is None:
            return v
        elif v is False:  # using isinstance(v, bool): won&#39;t work as False also is int of zero.
            return str(v)
        elif v is True:
            return str(v)
        elif isinstance(v, int):
            return v
        elif isinstance(v, str):
            return v
        elif isinstance(v, float):
            return v
        elif isinstance(v, datetime):
            return v.isoformat()
        elif isinstance(v, time):
            return v.isoformat()
        elif isinstance(v, date):
            return v.isoformat()
        else:
            raise TypeError(f&#34;The datatype {type(v)} is not supported.&#34;)

    @staticmethod
    def from_json(v, dtype):
        if v in DataTypes.nones:
            if dtype is str and v == &#34;&#34;:
                return &#34;&#34;
            else:
                return None
        if dtype is int:
            return int(v)
        elif dtype is str:
            return str(v)
        elif dtype is float:
            return float(v)
        elif dtype is bool:
            if v == &#39;False&#39;:
                return False
            elif v == &#39;True&#39;:
                return True
            else:
                raise ValueError(v)
        elif dtype is date:
            return date.fromisoformat(v)
        elif dtype is datetime:
            return datetime.fromisoformat(v)
        elif dtype is time:
            return time.fromisoformat(v)
        else:
            raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)

    @staticmethod
    def infer(v, dtype):
        if v in DataTypes.nones:
            return None
        if dtype is int:
            return DataTypes._infer_int(v)
        elif dtype is str:
            return DataTypes._infer_str(v)
        elif dtype is float:
            return DataTypes._infer_float(v)
        elif dtype is bool:
            return DataTypes._infer_bool(v)
        elif dtype is date:
            return DataTypes._infer_date(v)
        elif dtype is datetime:
            return DataTypes._infer_datetime(v)
        elif dtype is time:
            return DataTypes._infer_time(v)
        else:
            raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)

    @staticmethod
    def _infer_bool(value):
        if isinstance(value, bool):
            return value
        elif isinstance(value, int):
            raise ValueError(&#34;it&#39;s an integer.&#34;)
        elif isinstance(value, float):
            raise ValueError(&#34;it&#39;s a float.&#34;)
        elif isinstance(value, str):
            if value.lower() == &#34;true&#34;:
                return True
            elif value.lower() == &#34;false&#34;:
                return False
            else:
                raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_int(value):
        if isinstance(value, bool):
            raise ValueError(&#34;it&#39;s a boolean&#34;)
        if isinstance(value, int):
            return value
        elif isinstance(value, float):
            if int(value) == value:
                return int(value)
            raise ValueError(&#34;it&#39;s a float&#34;)
        elif isinstance(value, str):
            value = value.replace(&#39;&#34;&#39;, &#39;&#39;)  # &#34;1,234&#34; --&gt; 1,234
            value = value.replace(&#34; &#34;, &#34;&#34;)  # 1 234 --&gt; 1234
            value = value.replace(&#39;,&#39;, &#39;&#39;)  # 1,234 --&gt; 1234
            value_set = set(value)
            if value_set - DataTypes.integers:  # set comparison.
                raise ValueError
            try:
                return int(value)
            except Exception:
                raise ValueError(f&#34;{value} is not an integer&#34;)
        else:
            raise ValueError

    @staticmethod
    def _infer_float(value):
        if isinstance(value, int):
            raise ValueError(&#34;it&#39;s an integer&#34;)
        if isinstance(value, float):
            return value
        elif isinstance(value, str):
            value = value.replace(&#39;&#34;&#39;, &#39;&#39;)
            dot_index, comma_index = value.find(&#39;.&#39;), value.find(&#39;,&#39;)
            if dot_index == comma_index == -1:
                pass  # there are no dots or commas.
            elif 0 &lt; dot_index &lt; comma_index:  # 1.234,567
                value = value.replace(&#39;.&#39;, &#39;&#39;)  # --&gt; 1234,567
                value = value.replace(&#39;,&#39;, &#39;.&#39;)  # --&gt; 1234.567
            elif dot_index &gt; comma_index &gt; 0:  # 1,234.678
                value = value.replace(&#39;,&#39;, &#39;&#39;)

            elif comma_index and dot_index == -1:
                value = value.replace(&#39;,&#39;, &#39;.&#39;)
            else:
                pass

            value_set = set(value)

            if not value_set.issubset(DataTypes.decimals):
                raise TypeError

            # if it&#39;s a string, do also
            # check that reverse conversion is valid,
            # otherwise we have loss of precision. F.ex.:
            # int(0.532) --&gt; 0
            try:
                float_value = float(value)
            except Exception:
                raise ValueError(f&#34;{value} is not a float.&#34;)
            if value_set.intersection(&#39;Ee&#39;):  # it&#39;s scientific notation.
                v = value.lower()
                if v.count(&#39;e&#39;) != 1:
                    raise ValueError(&#34;only 1 e in scientific notation&#34;)

                e = v.find(&#39;e&#39;)
                v_float_part = float(v[:e])
                v_exponent = int(v[e + 1:])
                return float(f&#34;{v_float_part}e{v_exponent}&#34;)

            elif &#34;.&#34; in str(float_value) and not &#34;.&#34; in value_set:
                # when traversing through Datatype.types,
                # integer is presumed to have failed for the column,
                # so we ignore this and turn it into a float...
                reconstructed_input = str(int(float_value))

            elif &#34;.&#34; in value:
                precision = len(value) - value.index(&#34;.&#34;) - 1
                formatter = &#39;{0:.&#39; + str(precision) + &#39;f}&#39;
                reconstructed_input = formatter.format(float_value)

            else:
                reconstructed_input = str(float_value)

            if value.lower() != reconstructed_input:
                raise ValueError

            return float_value
        else:
            raise ValueError

    @staticmethod
    def _infer_date(value):
        if isinstance(value, date):
            return value
        elif isinstance(value, str):
            try:
                return date.fromisoformat(value)
            except ValueError:
                pattern = &#34;&#34;.join([&#34;N&#34; if n in DataTypes.digits else n for n in value])
                f = DataTypes.date_formats.get(pattern, None)
                if f:
                    return f(value)
                else:
                    raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_datetime(value):
        if isinstance(value, datetime):
            return value
        elif isinstance(value, str):
            try:
                return datetime.fromisoformat(value)
            except ValueError:
                if &#39;.&#39; in value:
                    dot = value.find(&#39;.&#39;, 11)  # 11 = len(&#34;1999.12.12&#34;)
                elif &#39;,&#39; in value:
                    dot = value.find(&#39;,&#39;, 11)
                else:
                    dot = len(value)

                pattern = &#34;&#34;.join([&#34;N&#34; if n in DataTypes.digits else n for n in value[:dot]])
                f = DataTypes.datetime_formats.get(pattern, None)
                if f:
                    return f(value)
                else:
                    raise ValueError
        else:
            raise ValueError

    @staticmethod
    def _infer_time(value):
        if isinstance(value, time):
            return value
        elif isinstance(value, str) and &#34;:&#34; in value:
            # beware time.fromisoformat reads &#34;20&#34; as &#34;20:00:00&#34;, despite that it is more likely to be an integer.
            return time.fromisoformat(value)
        else:
            raise ValueError

    @staticmethod
    def _infer_str(value):
        if isinstance(value, str):
            return value
        else:
            return str(value)

    # Order is very important!
    types = [datetime, date, time, int, bool, float, str]

    @staticmethod
    def infer_range_from_slice(slice_item, length):
        assert isinstance(slice_item, slice)
        assert isinstance(length, int)
        item = slice_item

        if all((item.start is None,
               item.stop is None,
               item.step is None)):
            return 0, length, 1

        if item.step is None or item.step &gt; 0:  # forward traverse
            step = 1 if item.step is None else item.step
            if item.start is None:
                start = 0
            elif item.start &lt; 0:
                start = length + item.start
            else:
                start = item.start

            if item.stop is None or item.stop &gt; length:
                stop = length
            elif item.stop &lt; 0:
                stop = length + item.stop
            else:
                stop = item.stop

        elif item.step == 0:
            raise ValueError(&#34;slice step cannot be zero&#34;)

        else:  # item.step &lt; 0: backward traverse
            step = item.step
            if item.start is None:  # a[::-1]
                start = length
            elif item.start &lt; 0:
                start = item.start + length
            else:
                start = item.start

            if item.stop is None:
                stop = 0
            elif item.stop &lt; 0:
                stop = item.stop + length
            else:
                stop = item.stop

        return start, stop, step</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tablite.datatypes.DataTypes.bool"><code class="name">var <span class="ident">bool</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.date"><code class="name">var <span class="ident">date</span></code></dt>
<dd>
<div class="desc"><p>date(year, month, day) &ndash;&gt; date object</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.date_formats"><code class="name">var <span class="ident">date_formats</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.datetime"><code class="name">var <span class="ident">datetime</span></code></dt>
<dd>
<div class="desc"><p>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</p>
<p>The year, month and day arguments are required. tzinfo may be None, or an
instance of a tzinfo subclass. The remaining arguments may be ints.</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.datetime_formats"><code class="name">var <span class="ident">datetime_formats</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.decimals"><code class="name">var <span class="ident">decimals</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.digits"><code class="name">var <span class="ident">digits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.float"><code class="name">var <span class="ident">float</span></code></dt>
<dd>
<div class="desc"><p>Convert a string or number to a floating point number, if possible.</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.int"><code class="name">var <span class="ident">int</span></code></dt>
<dd>
<div class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></div>
</dd>
<dt id="tablite.datatypes.DataTypes.integers"><code class="name">var <span class="ident">integers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.none_type"><code class="name">var <span class="ident">none_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.nones"><code class="name">var <span class="ident">nones</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.numeric_types"><code class="name">var <span class="ident">numeric_types</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tablite.datatypes.DataTypes.str"><code class="name">var <span class="ident">str</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) &ndash;&gt; a time object</p>
<p>All arguments are optional. tzinfo may be None, or an instance of
a tzinfo subclass. The remaining arguments may be ints.</p></div>
</dd>
<dt id="tablite.datatypes.DataTypes.types"><code class="name">var <span class="ident">types</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tablite.datatypes.DataTypes.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>v, dtype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(v, dtype):
    if v in DataTypes.nones:
        if dtype is str and v == &#34;&#34;:
            return &#34;&#34;
        else:
            return None
    if dtype is int:
        return int(v)
    elif dtype is str:
        return str(v)
    elif dtype is float:
        return float(v)
    elif dtype is bool:
        if v == &#39;False&#39;:
            return False
        elif v == &#39;True&#39;:
            return True
        else:
            raise ValueError(v)
    elif dtype is date:
        return date.fromisoformat(v)
    elif dtype is datetime:
        return datetime.fromisoformat(v)
    elif dtype is time:
        return time.fromisoformat(v)
    else:
        raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)</code></pre>
</details>
</dd>
<dt id="tablite.datatypes.DataTypes.infer"><code class="name flex">
<span>def <span class="ident">infer</span></span>(<span>v, dtype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def infer(v, dtype):
    if v in DataTypes.nones:
        return None
    if dtype is int:
        return DataTypes._infer_int(v)
    elif dtype is str:
        return DataTypes._infer_str(v)
    elif dtype is float:
        return DataTypes._infer_float(v)
    elif dtype is bool:
        return DataTypes._infer_bool(v)
    elif dtype is date:
        return DataTypes._infer_date(v)
    elif dtype is datetime:
        return DataTypes._infer_datetime(v)
    elif dtype is time:
        return DataTypes._infer_time(v)
    else:
        raise TypeError(f&#34;The datatype {str(dtype)} is not supported.&#34;)</code></pre>
</details>
</dd>
<dt id="tablite.datatypes.DataTypes.infer_range_from_slice"><code class="name flex">
<span>def <span class="ident">infer_range_from_slice</span></span>(<span>slice_item, length)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def infer_range_from_slice(slice_item, length):
    assert isinstance(slice_item, slice)
    assert isinstance(length, int)
    item = slice_item

    if all((item.start is None,
           item.stop is None,
           item.step is None)):
        return 0, length, 1

    if item.step is None or item.step &gt; 0:  # forward traverse
        step = 1 if item.step is None else item.step
        if item.start is None:
            start = 0
        elif item.start &lt; 0:
            start = length + item.start
        else:
            start = item.start

        if item.stop is None or item.stop &gt; length:
            stop = length
        elif item.stop &lt; 0:
            stop = length + item.stop
        else:
            stop = item.stop

    elif item.step == 0:
        raise ValueError(&#34;slice step cannot be zero&#34;)

    else:  # item.step &lt; 0: backward traverse
        step = item.step
        if item.start is None:  # a[::-1]
            start = length
        elif item.start &lt; 0:
            start = item.start + length
        else:
            start = item.start

        if item.stop is None:
            stop = 0
        elif item.stop &lt; 0:
            stop = item.stop + length
        else:
            stop = item.stop

    return start, stop, step</code></pre>
</details>
</dd>
<dt id="tablite.datatypes.DataTypes.pattern_to_datetime"><code class="name flex">
<span>def <span class="ident">pattern_to_datetime</span></span>(<span>iso_string, ymd=None, T=None, compact=0, day_first=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pattern_to_datetime(iso_string, ymd=None, T=None, compact=0, day_first=False):
    assert isinstance(iso_string, str)
    if compact:
        s = iso_string
        if compact == 1:  # has T
            slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (11, 13, &#34;:&#34;), (13, len(s), &#34;&#34;)]
        elif compact == 2:  # has no T.
            slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (8, 10, &#34;:&#34;), (10, 12, &#34;:&#34;), (12, len(s), &#34;&#34;)]
        elif compact == 3:  # has T and :
            slices = [(0, 4, &#34;-&#34;), (4, 6, &#34;-&#34;), (6, 8, &#34;T&#34;), (9, 11, &#34;:&#34;), (12, 14, &#34;:&#34;), (15, len(s), &#34;&#34;)]
        else:
            raise TypeError
        iso_string = &#34;&#34;.join([s[a:b] + c for a, b, c in slices if b &lt;= len(s)])
        iso_string = iso_string.rstrip(&#34;:&#34;)

    if day_first:
        s = iso_string
        iso_string = &#34;&#34;.join((s[6:10], &#34;-&#34;, s[3:5], &#34;-&#34;, s[0:2], s[10:]))

    if &#34;,&#34; in iso_string:
        iso_string = iso_string.replace(&#34;,&#34;, &#34;.&#34;)

    dot = iso_string[::-1].find(&#39;.&#39;)
    if 0 &lt; dot &lt; 10:
        ix = len(iso_string) - dot
        microsecond = int(float(f&#34;0{iso_string[ix - 1:]}&#34;) * 10 ** 6)
        iso_string = iso_string[:len(iso_string) - dot] + str(microsecond).rjust(6, &#34;0&#34;)
    if ymd:
        iso_string = iso_string.replace(ymd, &#39;-&#39;, 2)
    if T:
        iso_string = iso_string.replace(T, &#34;T&#34;)
    return datetime.fromisoformat(iso_string)</code></pre>
</details>
</dd>
<dt id="tablite.datatypes.DataTypes.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_json(v):
    if v is None:
        return v
    elif v is False:  # using isinstance(v, bool): won&#39;t work as False also is int of zero.
        return str(v)
    elif v is True:
        return str(v)
    elif isinstance(v, int):
        return v
    elif isinstance(v, str):
        return v
    elif isinstance(v, float):
        return v
    elif isinstance(v, datetime):
        return v.isoformat()
    elif isinstance(v, time):
        return v.isoformat()
    elif isinstance(v, date):
        return v.isoformat()
    else:
        raise TypeError(f&#34;The datatype {type(v)} is not supported.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tablite" href="index.html">tablite</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tablite.datatypes.DataTypes" href="#tablite.datatypes.DataTypes">DataTypes</a></code></h4>
<ul class="">
<li><code><a title="tablite.datatypes.DataTypes.bool" href="#tablite.datatypes.DataTypes.bool">bool</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.date" href="#tablite.datatypes.DataTypes.date">date</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.date_formats" href="#tablite.datatypes.DataTypes.date_formats">date_formats</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.datetime" href="#tablite.datatypes.DataTypes.datetime">datetime</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.datetime_formats" href="#tablite.datatypes.DataTypes.datetime_formats">datetime_formats</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.decimals" href="#tablite.datatypes.DataTypes.decimals">decimals</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.digits" href="#tablite.datatypes.DataTypes.digits">digits</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.float" href="#tablite.datatypes.DataTypes.float">float</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.from_json" href="#tablite.datatypes.DataTypes.from_json">from_json</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.infer" href="#tablite.datatypes.DataTypes.infer">infer</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.infer_range_from_slice" href="#tablite.datatypes.DataTypes.infer_range_from_slice">infer_range_from_slice</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.int" href="#tablite.datatypes.DataTypes.int">int</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.integers" href="#tablite.datatypes.DataTypes.integers">integers</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.none_type" href="#tablite.datatypes.DataTypes.none_type">none_type</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.nones" href="#tablite.datatypes.DataTypes.nones">nones</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.numeric_types" href="#tablite.datatypes.DataTypes.numeric_types">numeric_types</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.pattern_to_datetime" href="#tablite.datatypes.DataTypes.pattern_to_datetime">pattern_to_datetime</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.str" href="#tablite.datatypes.DataTypes.str">str</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.time" href="#tablite.datatypes.DataTypes.time">time</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.to_json" href="#tablite.datatypes.DataTypes.to_json">to_json</a></code></li>
<li><code><a title="tablite.datatypes.DataTypes.types" href="#tablite.datatypes.DataTypes.types">types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>